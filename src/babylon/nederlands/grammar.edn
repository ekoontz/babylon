[
 {:rule "conj-outer" ;; [.vier +[+en .twentig]]
  :unify [su/a
          ug/head-agr
          ug/head-last
          ug/head-sem]
  :cat :adjective
  :head {:cat :conjunction
         :agr {:number :plur}
         :phrasal true
         :rule "conj-inner"}
  :comp {:phrasal false}}

 {:rule "conj-inner" ;; +[+en .twentig]
  :unify [su/c
          ug/head-agr
          ug/head-first
          ug/head-sem]
  :cat :conjunction
  :head {:cat :conjunction
         :agr {:number :plur}
         :phrasal false
         :canonical "en"}}

 {:rule "intensifier-bar" ;; [.echt +kleine]
  :cat :adjective
  :head {:cat :adjective}
  :comp {:cat :intensifier}
  :unify [nest/cons-only
          su/b
          ug/head-is-root
          ug/head-last]}

 ;; [intensifier-phrase .echt +[intensifier-bar .echt +kleine]]
 {:rule "intensifier-phrase" 
  :cat :adjective
  :head {:cat :adjective}
  :comp {:cat :intensifier}
  :unify [nest/adjective
          nest/cons-and-nest
          su/b
          ug/head-is-root          
          ug/head-last]}

 ;; The next two rules, nbar:1 and nbar:2,
 ;; differ only in the value of [:mod :first :number?]:
 ;; the value at this path is true in the first, false in the second.
 ;; TODO: use :options instead to consolidate
 ;; into one rule.
 
 ;; [nbar:1 .vier +[nbar:3 .kleine +tafels]]
 {:rule "nbar:1"
  :cat :noun
  :head {:pronoun false
         :propernoun false
         :subcat {:1 {:top :top}
                  :2 []}}
  :slash false
  :comp {:cat :adjective
         :modifies-noun true}
  :mod {:first {:number? true}
        :rest {:first {:number? false}}}

  :unify [nest/cons-only
          nest/noun
          su/b
          ug/head-last
          ug/head-is-root
          ug/nominal-phrase
          ug/shared-agr
          ug/shared-def]}

 ;; [nbar:2 .slimme +[nbar:3 .ernstig +gebeid]]
 {:rule "nbar:2"
  :cat :noun 
  :head {:pronoun false
         :propernoun false
         :subcat {:1 {:top :top}
                  :2 []}}
  :slash false
  :comp {:cat :adjective
         :modifies-noun true}
  :mod {:first {:number? false}
        :rest {:first {:number? false}}}

  :unify [nest/cons-only
          nest/noun
          su/b
          ug/head-last
          ug/head-is-root
          ug/nominal-phrase
          ug/shared-agr
          ug/shared-def]}

 ;; TODO: consolidate nbar:3 and
 ;; and nbar:4 into one rule using :options,
 ;; just as with nbar:1 and nbar:2.
 ;; [nbar:3 .kleine +tafels]
 {:rule "nbar:3"
  :cat :noun
  :head {:pronoun false
         :propernoun false
         :subcat {:1 {:top :top}
                  :2 []}}
  :slash false
  :comp {:cat :adjective
         :modifies-noun true}
  :mod {:first {:number? false}
        :rest []}

  :unify [nest/cons-only
          nest/noun
          su/b          
          ug/head-is-root
          ug/head-last
          ug/nominal-phrase
          ug/shared-agr
          ug/shared-def]}

 ;; [nbar:4 .vier +tafels]
 {:rule "nbar:4"
  :cat :noun
  :head {:pronoun false
         :propernoun false
         :subcat {:1 {:top :top}
                  :2 []}}
  :slash false
  :comp {:cat :adjective
         :modifies-noun true}
  :mod {:first {:number? true}
        :rest []}

  :unify [nest/cons-only
          nest/noun
          su/b
          ug/head-last
          ug/head-is-root
          ug/head-rule
          ug/nominal-phrase
          ug/shared-agr
          ug/shared-def]}
 
 ;; np with no determiner, e.g.:
 ;; 'grote katten' in 'grote katten slapen'.
 {:rule "np:1" 
  :np? true
  :cat :noun
  :head {:pronoun false
         :propernoun false
         ;; Prevent e.g. *"oude de huizen",
         ;; whereas e.g. "de oude huizen" is ok:
         :np? false
         :subcat []}
  :slash false
  :comp {:cat :adjective
         :modifies-noun true}
  :unify [nest/cons-and-nest
          nest/noun
          su/b
          ug/head-is-root
          ug/head-last
          ug/head-rule
          ug/nominal-phrase
          ug/shared-agr
          ug/shared-def]}
 
 {:rule "np:2" ;; '.de +kat'
  :np? true
  :reflexive false
  :agr {:person :3rd}
  :cat :noun
  :comp {:cat :det}
  :slash false
  :mod []
  ;; TODO: remove this :options, if possible (test first, of course).
  :options [{:agr {:number :plur}}
            {:agr {:number :sing}}]
  :unify [nest/cons-and-nest
          nest/noun
          su/a
          ug/head-is-root
          ug/head-last
          ug/head-rule
          ug/shared-def
          ug/shared-number]}

 {:rule "s"
  :cat :verb
  :subcat []
  :options babylon.nederlands/finite-tenses  
  :unify [su/a
          ug/head-aux
          ug/head-is-root
          ug/head-last
          ug/head-rule
          ug/head-sem
          ug/sem-mod-is-empty ;; temporary until I figure out how to use [:head :sem :mod] for this rule.
          ]}

 {:rule "vp" ;; [vp +zie .het]
  :cat :verb
  :aux false
  :slash false
  :options babylon.nederlands/finite-plus-inf-tense
  :head {:aux false
         :modal false}

  :unify [su/c
          ug/head-first
          ug/head-is-root
          ug/head-reflexive
          ug/head-rule
          ug/head-sem
          ug/sem-mod-is-empty ;; temporary until I figure out how to use [:head :sem :mod] for this rule.
          ug/slash-is-head-slash]}

 {:rule "vp-modal-te" ;; [vp-modal-te +proberen .[te slapen]]
  :cat :verb
  :aux false
  :slash false
  :options babylon.nederlands/finite-plus-inf-tense
  :head {:aux false
         :modal :te}

  :unify [su/c
          ug/head-first
          ug/head-is-root
          ug/head-reflexive
          ug/head-rule
          ug/head-sem
          ug/sem-mod-is-empty
          ug/slash-is-head-slash]}

 ;; the object of the non-modal verb (in the complement)
 ;; is copied up:
 {:rule "vp-infinitive" ;; [vp +moet .bestrijden]
  :cat :verb
  :aux false
  :slash false
  :options babylon.nederlands/finite-plus-inf-tense
  :head {:aux false
         :modal :infinitive}
  :unify [su/i
          ug/head-first
          ug/head-is-root
          ug/nest-comp-mod
          ug/head-reflexive
          ug/head-rule
          ug/head-sem
          ug/slash-is-head-slash]}

 {:rule "vp-np" ;; [vp-np .[np de kat] [vp-te +te .zien]]
  :cat :verb
  :aux false
  :slash false
  :options babylon.nederlands/inf-tense
  :head {:aux false}

  ;; TODO: remove: should be handled by head:
  :comp {:cat :noun}
  :unify [su/c
          ug/head-last
          ug/head-is-root
          ug/head-reflexive
          ug/head-rule
          ug/head-sem
          ug/sem-mod-is-empty ;; temporary until I figure out how to use [:head :sem :mod] for this rule.
          ug/slash-is-head-slash]}

 {:rule "vp-te" ;; '+te .slapen'
  :cat :verb
  :aux false
  :slash false
  :infl :te
  :head {:canonical "te"}
  :unify [su/d
          ug/head-first
          ug/comp-is-root
          ug/head-reflexive
          ug/head-rule
          ug/head-sem
          ug/slash-is-head-slash
          ug/sem-mod-is-comp-mod]}

 {:rule "adverb" ;; '.samen +bestrijden'
  :prod? true
  :cat :verb
  :subcat {:1 {:top :top}
           :2 {:top :top}
           :3 []}
  :mod {:rest []}
  :reflexive false
  :head {:cat :verb
         :infl :infinitive}
  :comp {:cat :adverb}
  :unify [su/b

          ;; TODO: use nest/ instead.
          ug/cons-mod-adverb

          ug/subj-ref
          ug/head-is-root
          ug/head-last
          ug/head-rule
          ug/head-sem]}

 ;; [modal+subject(:present-simple) +moeten .jullie]
 {:rule "modal+subject"
  :prod? true
  :cat :verb
  :reflexive false
  :head {:phrasal false
         :modal :infinitive
         :infl :present
         :subcat {:2 {:modal false}}}
  :options babylon.nederlands/finite-tenses  
  :unify [su/e
          ug/head-first
          ug/head-rule
          ug/head-sem]}

 ;; +[vp-slash-object +[modal+subject(:present-simple) +moeten .we] .[adverb .samen +bestrijden]]
 {:rule "vp-slash-object"
  :prod? true
  :cat :verb
  :reflexive false
  :head {:rule "modal+subject"
         :phrasal true}
  :unify [su/h
          ug/head-first
          ug/head-sem]}]
