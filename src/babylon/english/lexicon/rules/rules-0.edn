[{:rule :regular-noun
  :if {:cat :noun
       :agr {:number ::unspec}
       :pronoun ::unspec
       :propernoun ::unspec
       :regular ::unspec
       :sem {:mod ::unspec}}
  :then [{:regular true
          :pronoun false
          :mod []
          :propernoun false}]}
 {:rule :complementizer
  :if {:cat :comp}
  :then [(let [sem (atom :top)
               agr (atom :top)]
           {:agr agr
            :sem sem
            :subcat {:1 {:agr agr
                         :sem sem}}})]}
 {:rule :preposition
  :if {:cat :prep}
  :then [(let [obj (atom :top)]
           {:cat :prep
            :subcat {:1 {:case :acc
                         :cat :noun
                         :subcat []
                         :sem obj}
                     :2 []}
            :sem {:obj obj}})]}

 ;; if a verb does not specify a particular
 ;; transitivity, generate both transitive and intransitive forms
 ;; of the verb.
 {:rule :subcat-unspecified
  :if {:cat :verb
       :aux false
       :subcat {:1 {:cat :noun}
                :2 ::unspec}}
  :then [{:subcat {:1 {:cat :noun}
                   :2 []}}
         {:subcat {:1 {:cat :noun}
                   :2 {:cat :noun}}}]}

 {:rule :aux-default-is-false
  :if {:cat :verb
       :aux ::unspec}
  :then [{:aux false}]}

 ;; <non-inflecting rules>
 ;;
 ;; Closed-class words don't inflect. Need to
 ;; set :inflected? so that babylon.lexiconfn/analyze
 ;; will find them properly.

 {:rule :dont-inflect-prepositions
  :if {:cat :prep}
  :then [{:inflected? true}]}

 {:rule :dont-inflect-determiners
  :if {:cat :det}
  :then [{:inflected? true}]}

 {:rule :dont-inflect-pronouns
  :if {:pronoun true}
  :then [{:inflected? true}]}

 {:rule :dont-inflect-propernouns
  :if {:propernoun true}
  :then [{:inflected? true}]}]



