[{:rule :regular-noun
  :if {:cat :noun
       :agr {:number ::unspec}
       :pronoun ::unspec
       :propernoun ::unspec
       :regular ::unspec
       :sem {:mod ::unspec}}
  :then [{:regular true
          :pronoun false
          :mod []
          :propernoun false}]}

 {:rule :nouns-are-inhuman-by-default
  :if {:cat :noun
       :agr {:human ::unspec}}
  :then [{:agr {:human false}}]}

 {:rule :complementizer
  :if {:cat :comp}
  :then [(let [sem (atom :top)
               agr (atom :top)]
           {:agr agr
            :sem sem
            :subcat {:1 {:agr agr
                         :sem sem}}})]}
 {:rule :preposition
  :if {:cat :prep}
  :then [(let [obj (atom :top)
               agr (atom :top)
               interogative? (atom :top)]
           {:cat :prep
            :interogative? interogative?
            :agr agr
            :reflexive true
            :subcat {:1 {:case :acc
                         :interogative? interogative?
                         :reflexive true
                         :cat :noun
                         :agr agr
                         :subcat []
                         :sem obj}
                     :2 []}
            :sem {:obj obj}})
         (let [obj (atom :top)
               interogative? (atom :top)]
           {:cat :prep
            :interogative? interogative?            
            :reflexive false
            :subcat {:1 {:case :acc
                         :interogative? interogative?
                         :reflexive false
                         :cat :noun
                         :subcat []
                         :sem obj}
                     :2 []}
            :sem {:obj obj}})]}

 ;; if a verb does not specify a particular
 ;; transitivity, generate both transitive and intransitive forms
 ;; of the verb, where the second form has a noun second argument.
 {:rule :subcat-unspecified-nonaux
  :if {:cat :verb
       :aux false
       :modal false
       :subcat {:1 {:cat :noun}
                :2 ::unspec}}
  :then [{:modal false
          :subcat {:1 {:cat :noun
                       :subcat []}
                   :2 []}}
         {:modal false
          :subcat {:1 {:cat :noun
                       :subcat []}
                   :2 {:cat :noun
                       :subcat []}}}]}
 
 {:rule :aux-default-is-false
  :if {:cat :verb
       :aux ::unspec}
  :then [{:aux false}]}

 ;; <non-inflecting rules>
 ;;
 ;; Closed-class words don't inflect. Need to
 ;; set :inflected? so that babylon.lexiconfn/analyze
 ;; will find them properly.

 {:rule :dont-inflect-adjectives
  :if {:cat :adjective}
  :then [{:inflected? true}]}

 {:rule :dont-inflect-complementizers
  :if {:cat :comp}
  :then [{:inflected? true}]}

 {:rule :dont-inflect-neg
  :if {:cat :neg}
  :then [{:inflected? true}]}
 
 {:rule :dont-inflect-prepositions
  :if {:cat :prep}
  :then [{:inflected? true}]}

 {:rule :dont-inflect-determiners
  :if {:cat :det}
  :then [{:inflected? true}]}
 
 ;; </non-inflecting rules>

 {:rule :modal-default-false
  :if {:cat :verb
       :modal ::unspec}
  :then [{:modal false}]}

 {:rule :pronouns-are-not-reflexive-by-default
  :if {:cat :noun
       :pronoun true
       :reflexive ::unspec}
  :then [{:reflexive false}]}

 {:rule :pronouns-are-not-wh-words-by-default
  :if {:cat :noun
       :pronoun true
       :wh-word ::unspec}
  :then [{:wh-word false}]}]
